
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Eco-Quest: Waste Sorter</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap');
        body {
            font-family: 'Inter', sans-serif;
            background-color: #e0f2fe;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            padding: 1rem;
            box-sizing: border-box;
        }
        .game-container {
            width: 100%;
            max-width: 800px;
            background-color: #fff;
            border-radius: 20px;
            box-shadow: 0 10px 25px rgba(0,0,0,0.1);
            overflow: hidden;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 1rem;
        }
        canvas {
            background-color: #a8dadc;
            border-radius: 15px;
            touch-action: none; /* Disable default touch actions */
            border: 3px solid #1d3557;
        }
        .bin-label {
            position: absolute;
            font-size: 1rem;
            font-weight: bold;
            color: #1d3557;
            text-align: center;
            bottom: 10px;
            left: 50%;
            transform: translateX(-50%);
            pointer-events: none;
        }
        .bin-label.recycling { color: #457b9d; }
        .bin-label.compost { color: #80b918; }
        .bin-label.trash { color: #e63946; }
        .feedback-message {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 2.5rem;
            font-weight: bold;
            color: white;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
            animation: fade-out 1.5s forwards;
            opacity: 0;
        }
        @keyframes fade-out {
            0% { opacity: 1; transform: translate(-50%, -50%) scale(1); }
            100% { opacity: 0; transform: translate(-50%, -50%) scale(1.5); }
        }
        .rounded-button {
            transition: transform 0.2s, box-shadow 0.2s;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
        }
        .rounded-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 8px rgba(0,0,0,0.15);
        }
        .rounded-button:active {
            transform: translateY(0);
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
    </style>
</head>
<body class="bg-blue-100 flex items-center justify-center min-h-screen p-4">
 <a href="{% url 'home' %}" class="mt-6 inline-block text-green-700 font-semibold hover:underline">‚Üê Back to Dashboard</a>
<div class="game-container">
    <!-- Game Title and UI -->
    <h1 class="text-3xl sm:text-4xl md:text-5xl font-extrabold text-blue-900 mb-2 text-center">
        Eco-Quest: Waste Sorter
    </h1>
    <p class="text-sm sm:text-base text-gray-600 mb-4 text-center">
        Sort the items into the correct bins before time runs out!
    </p>

    <div id="game-info" class="w-full flex justify-between items-center mb-4 text-blue-800 font-bold px-2 sm:px-4">
        <div class="text-lg">Score: <span id="score-value">0</span></div>
        <div class="text-lg">Time: <span id="time-value">0</span>s</div>
    </div>
    <div id="high-score-display" class="w-full text-center text-blue-800 font-bold mb-4 px-2 sm:px-4">
        High Score: <span id="high-score-value">0</span>
    </div>

    <!-- Canvas for the game -->
    <div id="canvas-container" class="relative w-full aspect-video max-h-[calc(100vh-250px)]">
        <canvas id="gameCanvas" class="w-full h-full"></canvas>
    </div>

    <!-- UI elements for menu and game over screen -->
    <div id="start-menu" class="absolute inset-0 bg-white bg-opacity-80 flex flex-col items-center justify-center rounded-2xl transition-opacity duration-300">
        <h2 class="text-3xl font-extrabold text-blue-900 mb-4">Ready to Play?</h2>
        <button id="startButton" class="rounded-full bg-blue-500 text-white text-lg sm:text-xl font-bold px-8 py-3 transition-colors hover:bg-blue-600 rounded-button">
            Start Game
        </button>
    </div>

    <div id="game-over-menu" class="absolute inset-0 bg-white bg-opacity-80 flex-col items-center justify-center hidden rounded-2xl transition-opacity duration-300">
        <h2 class="text-4xl font-extrabold text-blue-900 mb-4">Game Over!</h2>
        <p class="text-xl sm:text-2xl text-gray-700 mb-4">Final Score: <span id="final-score-value">0</span></p>
        <button id="restartButton" class="rounded-full bg-green-500 text-white text-lg sm:text-xl font-bold px-8 py-3 transition-colors hover:bg-green-600 rounded-button">
            Play Again
        </button>
    </div>
    <div id="user-id-display" class="mt-4 text-xs text-gray-400 text-center w-full break-words px-2">
        User ID: <span id="user-id-value">Loading...</span>
    </div>
</div>

<!-- Firebase SDKs and Game Script -->
<script type="module">
    import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
    import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
    import { getFirestore, doc, setDoc, onSnapshot, collection } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";
    import { setLogLevel } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

    setLogLevel('debug'); // Enable debug logging for Firestore

    // Global variables provided by the environment
    const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
    const firebaseConfig = JSON.parse(typeof __firebase_config !== 'undefined' ? __firebase_config : '{}');
    const initialAuthToken = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : null;

    let app;
    let auth;
    let db;
    let userId;

    let highscore = 0;

    // Initialize Firebase and Auth
    function initFirebase() {
        if (Object.keys(firebaseConfig).length > 0) {
            app = initializeApp(firebaseConfig);
            auth = getAuth(app);
            db = getFirestore(app);

            onAuthStateChanged(auth, async (user) => {
                if (user) {
                    userId = user.uid;
                    document.getElementById('user-id-value').textContent = userId;
                    await setupFirestoreListener();
                } else {
                    console.log("No user signed in. Attempting anonymous sign-in.");
                    try {
                        if (initialAuthToken) {
                            await signInWithCustomToken(auth, initialAuthToken);
                        } else {
                            await signInAnonymously(auth);
                        }
                    } catch (error) {
                        console.error("Firebase Auth Error:", error);
                        // A custom modal for error messages would go here instead of alert()
                    }
                }
            });
        } else {
            console.error("Firebase config is not available. High scores will not be saved.");
        }
    }

    async function setupFirestoreListener() {
        if (!db || !userId) {
            console.log("Firestore or user not ready, skipping listener setup.");
            return;
        }
        const userDocRef = doc(db, `artifacts/${appId}/users/${userId}/scores`, "highscores");
        onSnapshot(userDocRef, (docSnap) => {
            if (docSnap.exists()) {
                const data = docSnap.data();
                highscore = data.score || 0;
                document.getElementById('high-score-value').textContent = highscore;
            } else {
                console.log("No high score found for user, setting to 0.");
                highscore = 0;
            }
        });
    }

    async function saveHighscore() {
        if (!db || !userId) {
            console.error("Firestore not initialized or user not authenticated. Cannot save high score.");
            return;
        }

        const userDocRef = doc(db, `artifacts/${appId}/users/${userId}/scores`, "highscores");
        try {
            await setDoc(userDocRef, { score: highscore }, { merge: true });
            console.log("High score saved successfully!");
        } catch (error) {
            console.error("Error saving high score:", error);
        }
    }

    // --- Game Logic ---
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const startMenu = document.getElementById('start-menu');
    const gameOverMenu = document.getElementById('game-over-menu');
    const scoreValue = document.getElementById('score-value');
    const timeValue = document.getElementById('time-value');
    const finalScoreValue = document.getElementById('final-score-value');

    let gameLoop;
    let items = [];
    const bins = [];
    let score = 0;
    let gameTime = 60;
    let timerId;
    let isDragging = false;
    let draggedItem = null;
    let lastTime = 0;

    const ITEM_SIZE = 50;
    const BIN_WIDTH = 100;
    const BIN_HEIGHT = 120;
    const DROP_THRESHOLD = 50; // Distance to bin center to be considered a drop

    // Item types and their corresponding bins
    const itemData = [
        { type: 'recycling', text: '‚ôªÔ∏è', color: '#457b9d', shape: 'square' },
        { type: 'compost', text: 'üçé', color: '#80b918', shape: 'circle' },
        { type: 'trash', text: 'üç¨', color: '#e63946', shape: 'triangle' },
        { type: 'recycling', text: 'üì∞', color: '#457b9d', shape: 'square' },
        { type: 'compost', text: 'üçå', color: '#80b918', shape: 'circle' },
        { type: 'trash', text: 'ü•°', color: '#e63946', shape: 'triangle' },
    ];

    // Resize canvas and redraw game elements on window resize
    const resizeCanvas = () => {
        const container = document.getElementById('canvas-container');
        canvas.width = container.clientWidth;
        canvas.height = container.clientHeight;
        updateBinPositions();
    };

    const updateBinPositions = () => {
        const binSpacing = canvas.width / 4;
        bins[0] = { x: binSpacing - BIN_WIDTH / 2, y: canvas.height - BIN_HEIGHT - 20, type: 'recycling', color: '#457b9d', label: 'Recycling' };
        bins[1] = { x: 2 * binSpacing - BIN_WIDTH / 2, y: canvas.height - BIN_HEIGHT - 20, type: 'compost', color: '#80b918', label: 'Compost' };
        bins[2] = { x: 3 * binSpacing - BIN_WIDTH / 2, y: canvas.height - BIN_HEIGHT - 20, type: 'trash', color: '#e63946', label: 'Trash' };
    };

    const drawItems = () => {
        items.forEach(item => {
            ctx.fillStyle = item.color;
            ctx.beginPath();
            if (item.shape === 'square') {
                ctx.fillRect(item.x, item.y, ITEM_SIZE, ITEM_SIZE);
            } else if (item.shape === 'circle') {
                ctx.arc(item.x + ITEM_SIZE / 2, item.y + ITEM_SIZE / 2, ITEM_SIZE / 2, 0, Math.PI * 2);
                ctx.fill();
            } else if (item.shape === 'triangle') {
                ctx.moveTo(item.x + ITEM_SIZE / 2, item.y);
                ctx.lineTo(item.x, item.y + ITEM_SIZE);
                ctx.lineTo(item.x + ITEM_SIZE, item.y + ITEM_SIZE);
                ctx.closePath();
                ctx.fill();
            }
            ctx.fillStyle = 'white';
            ctx.font = `${ITEM_SIZE / 2}px sans-serif`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(item.text, item.x + ITEM_SIZE / 2, item.y + ITEM_SIZE / 2);
        });
    };

    const drawBins = () => {
        bins.forEach(bin => {
            ctx.fillStyle = bin.color;
            ctx.strokeStyle = '#1d3557';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.roundRect(bin.x, bin.y, BIN_WIDTH, BIN_HEIGHT, [15, 15, 0, 0]);
            ctx.fill();
            ctx.stroke();

            ctx.fillStyle = '#1d3557';
            ctx.font = '16px "Inter", sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText(bin.label, bin.x + BIN_WIDTH / 2, bin.y + BIN_HEIGHT + 20);
        });
    };

    const createItem = () => {
        if (items.length < 5) {
            const randomItem = itemData[Math.floor(Math.random() * itemData.length)];
            const newItem = {
                ...randomItem,
                x: Math.random() * (canvas.width - ITEM_SIZE),
                y: -ITEM_SIZE,
                vy: 1 + Math.random(),
                isDragging: false
            };
            items.push(newItem);
        }
    };

    const updateGame = () => {
        items.forEach(item => {
            if (!item.isDragging) {
                item.y += item.vy;
            }
        });
        items = items.filter(item => item.y < canvas.height + ITEM_SIZE);
    };

    const displayFeedback = (isCorrect) => {
        const message = document.createElement('div');
        message.className = 'feedback-message';
        message.textContent = isCorrect ? 'Correct! üéâ' : 'Oops! üòû';
        message.style.color = isCorrect ? '#2a9d8f' : '#e76f51';
        document.getElementById('canvas-container').appendChild(message);
        setTimeout(() => message.remove(), 1500);
    };

    const checkDrop = () => {
        if (!draggedItem) return;

        let placed = false;
        bins.forEach(bin => {
            const distanceX = Math.abs((draggedItem.x + ITEM_SIZE / 2) - (bin.x + BIN_WIDTH / 2));
            const distanceY = Math.abs((draggedItem.y + ITEM_SIZE / 2) - (bin.y + BIN_HEIGHT / 2));
            if (distanceX < DROP_THRESHOLD + ITEM_SIZE/2 && distanceY < DROP_THRESHOLD + ITEM_SIZE/2) {
                if (draggedItem.type === bin.type) {
                    score += 10;
                    displayFeedback(true);
                } else {
                    score -= 5;
                    displayFeedback(false);
                }
                items = items.filter(item => item !== draggedItem);
                placed = true;
            }
        });

        if (!placed) {
            // Return to original position if not dropped in a bin
            draggedItem.x = draggedItem.originalX;
            draggedItem.y = draggedItem.originalY;
        }

        draggedItem.isDragging = false;
        isDragging = false;
        draggedItem = null;
    };

    const getMousePos = (event) => {
        const rect = canvas.getBoundingClientRect();
        const clientX = event.touches ? event.touches[0].clientX : event.clientX;
        const clientY = event.touches ? event.touches[0].clientY : event.clientY;
        return {
            x: clientX - rect.left,
            y: clientY - rect.top
        };
    };

    const handleStart = (event) => {
        const pos = getMousePos(event);
        items.forEach(item => {
            if (pos.x > item.x && pos.x < item.x + ITEM_SIZE &&
                pos.y > item.y && pos.y < item.y + ITEM_SIZE) {
                isDragging = true;
                draggedItem = item;
                draggedItem.isDragging = true;
                draggedItem.originalX = item.x;
                draggedItem.originalY = item.y;
                // Move dragged item to the top of the draw order
                items = items.filter(i => i !== item);
                items.push(item);
            }
        });
    };

    const handleMove = (event) => {
        if (isDragging && draggedItem) {
            const pos = getMousePos(event);
            draggedItem.x = pos.x - ITEM_SIZE / 2;
            draggedItem.y = pos.y - ITEM_SIZE / 2;
        }
    };

    const handleEnd = () => {
        if (isDragging) {
            checkDrop();
        }
    };

    const startGame = () => {
        score = 0;
        gameTime = 60;
        items = [];
        startMenu.classList.add('hidden');
        gameOverMenu.classList.add('hidden');
        document.getElementById('start-menu').style.display = 'none';
        document.getElementById('game-over-menu').style.display = 'none';

        timerId = setInterval(() => {
            gameTime--;
            timeValue.textContent = gameTime;
            if (gameTime <= 0) {
                endGame();
            }
        }, 1000);

        // Spawn items initially
        for(let i=0; i<3; i++) {
            createItem();
        }

        gameLoop = requestAnimationFrame(animate);
    };

    const endGame = () => {
        cancelAnimationFrame(gameLoop);
        clearInterval(timerId);
        finalScoreValue.textContent = score;
        document.getElementById('game-over-menu').style.display = 'flex';

        if (score > highscore) {
            highscore = score;
            document.getElementById('high-score-value').textContent = highscore;
            if (db && userId) {
                saveHighscore();
            } else {
                 console.log("Not saving new high score as Firestore is not ready.");
            }
        }
    };

    // Main game loop
    const animate = (timestamp) => {
        const delta = timestamp - lastTime;
        if (delta > 1000) { // Limit item spawning frequency
            createItem();
            lastTime = timestamp;
        }

        ctx.clearRect(0, 0, canvas.width, canvas.height);

        updateGame();
        drawBins();
        drawItems();
        scoreValue.textContent = score;
        timeValue.textContent = gameTime;

        gameLoop = requestAnimationFrame(animate);
    };

    // Event Listeners for UI and Game
    document.getElementById('startButton').addEventListener('click', () => {
        startGame();
    });
    document.getElementById('restartButton').addEventListener('click', () => {
        startGame();
    });

    window.addEventListener('resize', resizeCanvas);
    resizeCanvas();

    // Canvas Event Listeners for drag-and-drop
    canvas.addEventListener('mousedown', handleStart);
    canvas.addEventListener('mousemove', handleMove);
    canvas.addEventListener('mouseup', handleEnd);
    canvas.addEventListener('mouseleave', handleEnd);

    // Touch events for mobile
    canvas.addEventListener('touchstart', (e) => {
        e.preventDefault();
        handleStart(e);
    });
    canvas.addEventListener('touchmove', (e) => {
        e.preventDefault();
        handleMove(e);
    });
    canvas.addEventListener('touchend', (e) => {
        e.preventDefault();
        handleEnd(e);
    });

    window.onload = function() {
        initFirebase();
        updateBinPositions();
    };

</script>
</body>
</html>